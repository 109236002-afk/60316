<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æˆ‘çš„ä¸–ç•Œv1.0(Alpha)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* åŸºç¤æ¨£å¼ */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #2c3e50;
            font-family: 'Inter', sans-serif;
            color: #ecf0f1;
        }

        canvas {
            display: block;
        }

        /* --- éŠæˆ² HUD å…ƒç´  --- */
        
        /* ä¿æŒ health-bar çš„å‹•ç•«æ•ˆæœ */
        #health-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: #e74c3c;
            transition: width 0.3s ease;
        }
        
        /* HUD å…ƒç´ çš„æ¨£å¼èª¿æ•´ç‚ºä½¿ç”¨ Tailwindï¼Œä½†ä¿ç•™ä¸€äº›æ ¸å¿ƒ CSS */
        #health-text {
            position: relative;
            z-index: 1;
            font-size: 0.9rem;
            font-weight: bold;
            color: white;
        }
        
        #time-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 1.2rem;
            z-index: 100;
        }

        #durability-display {
            position: absolute;
            top: 60px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px;
            border-radius: 5px;
            font-size: 0.9rem;
            z-index: 100;
            display: none; /* é è¨­éš±è— */
            min-width: 150px;
            text-align: center;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background-color: white;
            border: 1px solid black;
            pointer-events: none;
            z-index: 100;
        }
        
        #message-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            min-height: 20px;
            text-align: center;
            z-index: 100;
        }

        /* --- åº«å­˜ UI æ¨£å¼ --- */
        #inventory-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none; /* é è¨­éš±è— */
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        #inventory-content {
            background-color: #5c6e7a; /* æ·ºè—ç°è‰²èƒŒæ™¯ */
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            border: 3px solid #34495e;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .inventory-grid-container {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 4px; /* ç·Šæ¹Šçš„æ ¼å­é–“è· */
        }
        
        .inventory-slot {
            width: 45px;
            height: 45px;
            background-color: #8395a7; 
            border: 2px solid #5c6e7a; 
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            transition: all 0.05s ease-out;
            user-select: none;
        }
        .inventory-slot:hover {
            background-color: #98a9b9;
        }
        .inventory-slot.selected-hotbar {
            border: 3px solid #f39c12; /* å¿«æ·æ¬„é¸ä¸­é‚Šæ¡† */
        }

        .item-icon {
            font-size: 24px;
            line-height: 1;
            user-select: none;
            pointer-events: none;
        }

        .stack-count {
            position: absolute;
            bottom: 0;
            right: 2px;
            color: white;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000, -1px -1px 0 #000;
            user-select: none;
            pointer-events: none;
        }
        
        .dragging {
            opacity: 0.5;
            transform: scale(1.05);
        }

        /* å¿«æ·æ¬„åœ¨éŠæˆ²ä¸­çš„é¡¯ç¤º */
        #hotbar-hud {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 4px;
            z-index: 10;
        }

        #hotbar-hud .inventory-slot {
            width: 50px;
            height: 50px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 2px solid #3c3c3c;
        }

        #hotbar-hud .inventory-slot.selected-hotbar {
            border: 3px solid #f39c12;
            background-color: rgba(0, 0, 0, 0.6);
        }
        
        #item-info-panel {
            min-height: 50px;
            background-color: #34495e;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #2c3e50;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* è£½ä½œæŒ‰éˆ• */
        .craft-button {
            padding: 8px 15px;
            border-radius: 6px;
            background-color: #2ecc71;
            color: white;
            font-weight: bold;
            transition: background-color 0.2s;
        }

        .craft-button:hover {
            background-color: #27ae60;
        }

        .craft-button:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <!-- éŠæˆ² HUD å…ƒç´  -->
    <div id="crosshair"></div>
    
    <!-- ç”Ÿå‘½å€¼å®¹å™¨ (ä½¿ç”¨ Tailwind å®šä½) -->
    <div class="absolute top-5 left-5 z-[100] flex items-center gap-3">
        <div id="health-container" class="w-[200px] h-[30px] border-2 border-white rounded-md overflow-hidden flex items-center justify-center bg-black/50">
            <div id="health-bar"></div>
            <span id="health-text">50 / 100</span>
        </div>
    </div>
    
    <div id="time-display">æ™‚é–“: 06:00</div>
    <div id="durability-display">è€ä¹…åº¦: 60 / 60</div>
    <div id="message-box">é»æ“Šç•«é¢ä»¥é–‹å§‹éŠæˆ²ï¼ŒæŒ‰ C éµæ‰“é–‹èƒŒåŒ…ã€‚éŠæˆ²æ™‚é–“ç‚º 1:60 åŠ é€Ÿã€‚</div>

    <!-- éŠæˆ²ä¸­å¿«æ·æ¬„é¡¯ç¤º -->
    <div id="hotbar-hud" class="hotbar-grid-container">
        <!-- 9 å€‹æ ¼å­ç”± JS æ¸²æŸ“ -->
    </div>

    <!-- åº«å­˜/åˆæˆæ¨¡æ…‹è¦–çª— -->
    <div id="inventory-modal">
        <div id="inventory-content" class="w-full max-w-xl">
            <!-- ç‰©å“è³‡è¨Šé¢æ¿ -->
            <div id="item-info-panel">
                <p id="item-name" class="text-lg font-bold text-yellow-300">è«‹é»æ“Šä¸€å€‹æ ¼å­...</p>
                <p id="item-details" class="text-sm text-gray-300"></p>
            </div>
            
            <!-- ä¸»åº«å­˜ (3x9 = 27) -->
            <div class="flex flex-col gap-2">
                <h3 class="text-sm font-semibold text-gray-200">ä¸»åº«å­˜ (Main Inventory)</h3>
                <div id="main-inventory-grid" class="inventory-grid-container"></div>
            </div>

            <!-- å¿«æ·æ¬„ (1x9 = 9) -->
            <div class="flex flex-col gap-2">
                <h3 class="text-sm font-semibold text-gray-200">å¿«æ·æ¬„ (Hotbar)</h3>
                <div id="inventory-hotbar-grid" class="inventory-grid-container"></div>
            </div>
            
            <!-- ç°¡æ˜“åˆæˆå€ -->
            <div class="flex flex-col gap-3 p-3 bg-gray-700/50 rounded-lg">
                <h3 class="text-lg font-bold text-emerald-300">ç°¡æ˜“åˆæˆ (Crafting)</h3>
                <div class="flex flex-wrap gap-3 justify-center">
                    <button class="craft-button" onclick="craftItem(6, {3: 4})" data-name="çŸ³ç£š">4 çŸ³é ­ â†’ 1 çŸ³ç£š</button>
                    <button class="craft-button" onclick="craftItem(7, {4: 1})" data-name="æœ¨æ¿">1 æœ¨é ­ â†’ 4 æœ¨æ¿</button>
                    <button class="craft-button" onclick="craftItem(8, {7: 2})" data-name="æœ¨æ£">2 æœ¨æ¿ â†’ 4 æœ¨æ£</button>
                    <button class="craft-button" onclick="craftItem(9, {8: 2, 7: 3})" data-name="æœ¨é¬">2 æœ¨æ£ + 3 æœ¨æ¿ â†’ 1 æœ¨é¬</button>
                </div>
            </div>

        </div>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script>
        (function() {
            // --- å…¨åŸŸè®Šæ•¸å’ŒéŠæˆ²ç‹€æ…‹ ---
            const messageBox = document.getElementById('message-box');
            const healthBar = document.getElementById('health-bar');
            const healthText = document.getElementById('health-text');
            const durabilityDisplay = document.getElementById('durability-display');
            const timeDisplay = document.getElementById('time-display');
            
            const inventoryModal = document.getElementById('inventory-modal');
            const mainInventoryGrid = document.getElementById('main-inventory-grid');
            const inventoryHotbarGrid = document.getElementById('inventory-hotbar-grid');
            const hotbarHUD = document.getElementById('hotbar-hud');
            const itemNameDisplay = document.getElementById('item-name');
            const itemDetailsDisplay = document.getElementById('item-details');
            
            let scene, camera, renderer, world;
            let ambientLight, directionalLight;
            let player, playerBody;
            let lastTime; 
            let lastCullTime = 0;
            const cullingDistance = 50;
            let isGameOver = false;
            let isInventoryOpen = false; // ç‹€æ…‹ï¼šåº«å­˜æ˜¯å¦é–‹å•Ÿ
            let draggedSlot = null; // æ‹–æ›³ç‹€æ…‹è¿½è¹¤
            
            // ç©å®¶ç‹€æ…‹
            let playerHealth = 50; // <--- è¨­ç½®åˆå§‹ç”Ÿå‘½å€¼ç‚º 50
            const maxHealth = 100;
            const playerDamage = 10; 
            let canJump = false; 
            let fallStartY = null;
            let isFalling = false;
            const minFallHeight = 10; 
            const fallDamageFactor = 2; 

            // æŒ–æ˜ç‹€æ…‹
            let isDigging = false;
            let diggingStartTime = 0;
            let diggingBlockId = null;
            let diggingEffect = null;
            const blockMeshes = new Map();
            const blockBodies = new Map();

            // ç”Ÿç‰©è¿½è¹¤
            const pigMeshes = [];
            const pigBodies = [];
            const saplingGrowthTracker = new Map(); 

            // éµç›¤ç‹€æ…‹
            const keyboard = {};
            
            // --- åº«å­˜èˆ‡ç‰©å“å®šç¾© ---
            const BLOCK_DIMENSIONS = 1;
            const WOODEN_PICKAXE_MAX_DURABILITY = 60;
            let currentPickaxeDurability = WOODEN_PICKAXE_MAX_DURABILITY; 
            let selectedHotbarIndex = 0; // å¿«æ·æ¬„ 0-8

            // ç‰©å“å®šç¾© (ItemId å¿…é ˆèˆ‡éŠæˆ²å…§æ–¹å¡Š/ç‰©å“åç¨±å°æ‡‰)
            const itemDefinitions = {
                1: { name: "è‰æ–¹å¡Š", maxStack: 64, icon: "ğŸŒ¿", blockType: 'grass' },
                2: { name: "æ³¥åœŸ", maxStack: 64, icon: "ğŸŸ«", blockType: 'dirt' },
                3: { name: "çŸ³é ­", maxStack: 64, icon: "ğŸª¨", blockType: 'stone' },
                4: { name: "æœ¨é ­", maxStack: 64, icon: "ğŸªµ", blockType: 'wood' },
                5: { name: "æ¨¹è‘‰", maxStack: 64, icon: "ğŸƒ", blockType: 'leaves' },
                6: { name: "çŸ³ç£š", maxStack: 64, icon: "ğŸ§±", blockType: 'stone_bricks' },
                7: { name: "æœ¨æ¿", maxStack: 64, icon: "ğŸšª", blockType: 'wooden_planks' },
                8: { name: "æœ¨æ£", maxStack: 64, icon: "ğŸ¥¢", blockType: 'sticks' },
                9: { name: "æœ¨é¬", maxStack: 1, icon: "â›ï¸", blockType: 'wooden_pickaxe', tool: true },
                10: { name: "æ¨¹è‹—", maxStack: 64, icon: "ğŸŒ±", blockType: 'sapling' },
                11: { name: "è±¬è‚‰", maxStack: 64, icon: "ğŸ¥©", blockType: 'pork', edible: true }
            };

            // åº«å­˜é™£åˆ— (0-26 ä¸»åº«å­˜, 27-35 å¿«æ·æ¬„)
            let inventoryData = new Array(36).fill(null).map((_, index) => ({ slot: index, itemId: null, stack: 0 }));

            // --- åˆå§‹ç‰©å“è¨­å®š (åªçµ¦äºˆè‰æ–¹å¡Šåœ¨å¿«æ·æ¬„ç¬¬ä¸€å€‹æ ¼å­, ç¬¬äºŒå€‹æ ¼å­çµ¦è±¬è‚‰) ---
            inventoryData[27] = { slot: 27, itemId: 1, stack: 64 }; // è‰æ–¹å¡Š
            inventoryData[28] = { slot: 28, itemId: 11, stack: 5 }; // è±¬è‚‰ (ç”¨æ–¼æ¸¬è©¦)
            // ---------------------------------------------------
            
            // æ–¹å¡Šé¡è‰²å°æ‡‰ (ç”¨æ–¼ 3D æ¸²æŸ“)
            const blockColors = {
                'grass': 0x2ecc71, 'dirt': 0x8b4513, 'stone': 0x95a5a6, 'wood': 0x7d5e4a,
                'leaves': 0x27ae60, 'stone_bricks': 0x7f8c8d, 'pig': 0xffa07a, 'empty': 0x70a1d6,
                'wooden_planks': 0x966F33, 'sticks': 0x8A4B2A, 'sapling': 0x559e31, 'pork': 0xFF69B4,
                'wooden_pickaxe': 0x9e7354
            };

            // æ–¹å¡ŠæŒ–æ˜æ™‚é–“ (æ¯«ç§’)
            const blockDurations = {
                'grass': 1000, 'dirt': 1000, 'stone': 2000, 'wood': 5000,
                'leaves': 500, 'stone_bricks': 2000, 'wooden_planks': 1000,
                'sticks': 1000, 'sapling': 500
            };

            // æ™‚é–“ç³»çµ±
            let gameTime = 6.0; // åˆå§‹æ™‚é–“ç‚ºæ—©ä¸Š 6 é»
            
            // éŠæˆ²æ™‚é–“åŠ é€Ÿä¿‚æ•¸: ç¾å¯¦ 1 ç§’ = éŠæˆ² 1 åˆ†é˜ (1/60 éŠæˆ²å°æ™‚)
            const REAL_SECOND_TO_GAME_HOUR_FACTOR = 1 / 60; 
            
            // --- è¼”åŠ©å‡½æ•¸ï¼šåº«å­˜å’Œç‰©å“ ---

            /**
             * å–å¾—ç•¶å‰å¿«æ·æ¬„é¸ä¸­çš„ç‰©å“ç‰©ä»¶ã€‚
             * @returns {object} ç•¶å‰é¸ä¸­çš„æ ¼å­ç‰©ä»¶ã€‚
             */
            function getSelectedItem() {
                return inventoryData[27 + selectedHotbarIndex];
            }

            /**
             * æ ¹æ“šæ–¹å¡Šçš„ Three.js é¡å‹åç¨±æŸ¥æ‰¾å°æ‡‰çš„ Item IDã€‚
             * @param {string} blockType - æ–¹å¡Šé¡å‹å­—ä¸² (e.g., 'grass', 'stone')
             * @returns {number | null} å°æ‡‰çš„ Item ID æˆ– null
             */
            function getItemIdByBlockType(blockType) {
                const entry = Object.entries(itemDefinitions).find(([, def]) => def.blockType === blockType);
                return entry ? parseInt(entry[0]) : null;
            }

            /**
             * å°‡ç‰©å“æ·»åŠ åˆ°åº«å­˜ä¸­ã€‚
             * @param {number} itemId - ç‰©å“IDã€‚
             * @param {number} count - æ•¸é‡ã€‚
             */
            function addItemToInventory(itemId, count) {
                if (!itemDefinitions[itemId]) return;

                const maxStack = itemDefinitions[itemId].maxStack;
                let remaining = count;

                // å˜—è©¦å †ç–Šåˆ°ç¾æœ‰æ ¼å­
                for (let i = 0; i < inventoryData.length && remaining > 0; i++) {
                    if (inventoryData[i].itemId === itemId && inventoryData[i].stack < maxStack) {
                        const canAdd = maxStack - inventoryData[i].stack;
                        const toAdd = Math.min(remaining, canAdd);
                        inventoryData[i].stack += toAdd;
                        remaining -= toAdd;
                    }
                }

                // å˜—è©¦æ”¾å…¥ç©ºæ§½
                for (let i = 0; i < inventoryData.length && remaining > 0; i++) {
                    if (inventoryData[i].itemId === null) {
                        const toAdd = Math.min(remaining, maxStack);
                        inventoryData[i].itemId = itemId;
                        inventoryData[i].stack = toAdd;
                        remaining -= toAdd;
                    }
                }

                if (remaining > 0) {
                    showMessage(`åº«å­˜å·²æ»¿ï¼Œç„¡æ³•å–å¾— ${itemDefinitions[itemId].name} x ${remaining}`);
                }
                renderInventoryUI();
            }

            // --- åº«å­˜ UI æ¸²æŸ“é‚è¼¯ ---

            /**
             * æ¸²æŸ“å–®ä¸€åº«å­˜æ ¼å­ã€‚
             * @param {number} index - åº«å­˜é™£åˆ—ç´¢å¼•ã€‚
             * @param {HTMLElement} container - å®¹ç´æ ¼å­çš„ DOM å…ƒç´ ã€‚
             * @param {boolean} isHotbar - æ˜¯å¦ç‚ºå¿«æ·æ¬„ã€‚
             */
            function renderSlot(index, container, isHotbar) {
                const item = inventoryData[index];
                const definition = itemDefinitions[item.itemId];

                const slotEl = document.createElement('div');
                slotEl.className = 'inventory-slot rounded-md';
                slotEl.setAttribute('data-slot-index', index);
                slotEl.setAttribute('draggable', item.itemId !== null);

                let content = '';
                if (item.itemId !== null) {
                    content += `<span class="item-icon">${definition.icon}</span>`;
                    if (item.stack > 1) {
                        content += `<span class="stack-count">${item.stack}</span>`;
                    }
                }
                slotEl.innerHTML = content;
                
                // å¿«æ·æ¬„é¸ä¸­ç‹€æ…‹
                if (isHotbar && (index - 27) === selectedHotbarIndex) {
                    slotEl.classList.add('selected-hotbar');
                }

                // åƒ…åœ¨æ¨¡æ…‹è¦–çª—æ‰“é–‹æ™‚æ·»åŠ æ‹–æ›³äº‹ä»¶ï¼Œå¦å‰‡åªæ·»åŠ é»æ“Š
                if (isInventoryOpen) {
                    slotEl.addEventListener('click', () => handleSlotClick(index));
                    slotEl.addEventListener('dragstart', handleDragStart);
                    slotEl.addEventListener('dragover', handleDragOver);
                    slotEl.addEventListener('drop', handleDrop);
                    slotEl.addEventListener('dragend', handleDragEnd);
                } else if (isHotbar) {
                     // éŠæˆ²ä¸­å¿«æ·æ¬„é»æ“Šæ™‚ï¼Œåˆ‡æ›é¸ä¸­ç‹€æ…‹
                    slotEl.addEventListener('click', () => {
                        selectedHotbarIndex = index - 27;
                        renderInventoryUI();
                    });
                }
                
                container.appendChild(slotEl);
            }

            /**
             * é‡æ–°ç¹ªè£½æ‰€æœ‰åº«å­˜å’Œå¿«æ·æ¬„ UIã€‚
             */
            function renderInventoryUI() {
                // 1. æ¸²æŸ“ä¸»åº«å­˜ (0-26)
                mainInventoryGrid.innerHTML = '';
                for (let i = 0; i < 27; i++) {
                    renderSlot(i, mainInventoryGrid, false);
                }

                // 2. æ¸²æŸ“æ¨¡æ…‹è¦–çª—ä¸­çš„å¿«æ·æ¬„ (27-35)
                inventoryHotbarGrid.innerHTML = '';
                for (let i = 27; i < 36; i++) {
                    renderSlot(i, inventoryHotbarGrid, true);
                }
                
                // 3. æ¸²æŸ“éŠæˆ²ä¸­çš„ HUD å¿«æ·æ¬„ (27-35)
                hotbarHUD.innerHTML = '';
                for (let i = 27; i < 36; i++) {
                    renderSlot(i, hotbarHUD, true);
                }
                
                // 4. æ›´æ–°å·¥å…·è€ä¹…åº¦é¡¯ç¤º
                updateDurabilityUI();
            }

            /**
             * è™•ç†æ ¼å­é»æ“Šäº‹ä»¶ (åƒ…åœ¨åº«å­˜é–‹å•Ÿæ™‚)ã€‚
             * @param {number} index - è¢«é»æ“Šçš„æ ¼å­ç´¢å¼•ã€‚
             */
            function handleSlotClick(index) {
                // æ¸…é™¤ info panel çš„é¸ä¸­ç‹€æ…‹ï¼Œä½†ä¿ç•™ hotbar çš„ selected-hotbar
                document.querySelectorAll('#main-inventory-grid .inventory-slot, #inventory-hotbar-grid .inventory-slot').forEach(el => el.classList.remove('active'));

                const item = inventoryData[index];
                const slotEl = document.querySelector(`#inventory-modal [data-slot-index="${index}"]`);
                
                if (slotEl) {
                    slotEl.classList.add('active');
                }

                if (item.itemId !== null) {
                    const definition = itemDefinitions[item.itemId];
                    itemNameDisplay.textContent = `ç‰©å“: ${definition.name}`;
                    itemDetailsDisplay.innerHTML = `
                        å †ç–Šæ•¸é‡: ${item.stack}<br>
                        æœ€å¤§å †ç–Š: ${definition.maxStack}<br>
                        åº«å­˜ç´¢å¼•: ${index} (${index < 27 ? 'ä¸»åº«å­˜' : 'å¿«æ·æ¬„'})
                    `;
                } else {
                    itemNameDisplay.textContent = `ç©ºæ§½ (ç´¢å¼•: ${index})`;
                    itemDetailsDisplay.textContent = 'æ­¤æ§½ä½ç›®å‰æ²’æœ‰ä»»ä½•ç‰©å“ã€‚';
                }
            }

            // --- æ‹–æ”¾é‚è¼¯ ---
            function handleDragStart(e) {
                const index = parseInt(e.target.getAttribute('data-slot-index'));
                if (inventoryData[index].itemId === null) {
                    e.preventDefault();
                    return;
                }
                draggedSlot = index;
                e.dataTransfer.setData('text/plain', index);
                setTimeout(() => e.target.classList.add('dragging'), 0);
            }

            function handleDragOver(e) {
                e.preventDefault(); 
            }

            function handleDrop(e) {
                e.preventDefault();
                const targetIndex = parseInt(e.currentTarget.getAttribute('data-slot-index'));
                const sourceIndex = draggedSlot;

                if (sourceIndex === null || sourceIndex === targetIndex) return;

                // åŸ·è¡Œç‰©å“äº¤æ› (ç°¡å–®äº¤æ›é‚è¼¯)
                [inventoryData[sourceIndex], inventoryData[targetIndex]] = 
                [inventoryData[targetIndex], inventoryData[sourceIndex]];

                // æ›´æ–° slot ç´¢å¼• (é›–ç„¶åœ¨é€™å€‹æ‡‰ç”¨ä¸­ slot å±¬æ€§ä¸åš´æ ¼éœ€è¦ï¼Œä½†ä¿æŒè³‡æ–™å®Œæ•´æ€§)
                inventoryData[sourceIndex].slot = sourceIndex;
                inventoryData[targetIndex].slot = targetIndex;

                renderInventoryUI();
                handleSlotClick(targetIndex);
            }

            function handleDragEnd(e) {
                e.target.classList.remove('dragging');
                draggedSlot = null; 
            }
            
            // --- åˆæˆé‚è¼¯ ---
            
            /**
             * å˜—è©¦åˆæˆç‰©å“ã€‚
             * @param {number} resultItemId - åˆæˆå¾Œçš„ç‰©å“IDã€‚
             * @param {object} recipe - æ‰€éœ€ææ–™ {itemId: count}ã€‚
             */
            window.craftItem = function(resultItemId, recipe) {
                const resultDef = itemDefinitions[resultItemId];
                if (!resultDef) return;

                // 1. æª¢æŸ¥ææ–™æ˜¯å¦è¶³å¤ 
                let canCraft = true;
                for (const [requiredItemIdStr, requiredCount] of Object.entries(recipe)) {
                    const requiredItemId = parseInt(requiredItemIdStr);
                    let foundCount = 0;
                    
                    // éæ­·æ‰€æœ‰æ ¼å­è¨ˆç®—ç¸½æ•¸
                    inventoryData.forEach(item => {
                        if (item.itemId === requiredItemId) {
                            foundCount += item.stack;
                        }
                    });

                    if (foundCount < requiredCount) {
                        canCraft = false;
                        showMessage(`ç¼ºå°‘ææ–™: ${itemDefinitions[requiredItemId].name} x ${requiredCount - foundCount}`);
                        break;
                    }
                }

                if (canCraft) {
                    // 2. æ¶ˆè€—ææ–™ (å¾åº«å­˜ä¸­ç§»é™¤)
                    for (const [requiredItemIdStr, requiredCount] of Object.entries(recipe)) {
                        let toRemove = requiredCount;
                        const requiredItemId = parseInt(requiredItemIdStr);
                        
                        // å¾å¾Œå¾€å‰ç§»é™¤ (é¿å…å½±éŸ¿å¿«æ·æ¬„)
                        for (let i = inventoryData.length - 1; i >= 0 && toRemove > 0; i--) {
                            const item = inventoryData[i];
                            if (item.itemId === requiredItemId) {
                                const removed = Math.min(toRemove, item.stack);
                                item.stack -= removed;
                                toRemove -= removed;

                                if (item.stack <= 0) {
                                    item.itemId = null;
                                    item.stack = 0;
                                }
                            }
                        }
                    }

                    // 3. ç”¢å‡ºçµæœ
                    // æœ¨æ¿å’Œæœ¨æ£é€šå¸¸ä¸€æ¬¡ç”¢å‡ºå¤šå€‹
                    let outputCount = 1;
                    if (resultItemId === 7) outputCount = 4; // æœ¨æ¿
                    if (resultItemId === 8) outputCount = 4; // æœ¨æ£
                    
                    addItemToInventory(resultItemId, outputCount);
                    showMessage(`æˆåŠŸåˆæˆ ${resultDef.name} x ${outputCount}ï¼`);
                }
            }


            // --- éŠæˆ²åˆå§‹åŒ–å’Œè¿´åœˆ (æ²¿ç”¨ NaN ä¿®æ­£å¾Œçš„ä»£ç¢¼) ---
            
            function init() {
                // THREE.js å’Œ CANNON.js åˆå§‹åŒ–...
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                scene.add(directionalLight);

                world = new CANNON.World();
                world.gravity.set(0, -9.82, 0);
                world.broadphase = new CANNON.NaiveBroadphase();

                generateWorld();
                createPigs();

                // äº‹ä»¶ç›£è½å™¨
                window.addEventListener('keydown', onKeyDown);
                window.addEventListener('keyup', (e) => keyboard[e.key] = false);
                window.addEventListener('resize', onWindowResize);
                window.addEventListener('mousedown', onMouseDown);
                window.addEventListener('mouseup', onMouseUp);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('pointerlockchange', pointerLockChange, false);
                
                // åˆå§‹ UI æ¸²æŸ“å’Œç©å®¶å‰µå»º
                renderInventoryUI();
                updateHealthUI(); // å°‡é¡¯ç¤º 50/100
                updateTimeAndLighting(gameTime); 
                createPlayer(); 
                
                requestAnimationFrame(animate);
                
                // é¦–æ¬¡å˜—è©¦é–å®šæ»‘é¼ 
                document.body.requestPointerLock().catch(() => {});
            }


            // --- éŠæˆ²äº‹ä»¶è™•ç† (éƒ¨åˆ†æ›´æ–°) ---
            
            function onKeyDown(e) {
                keyboard[e.key] = true;
                
                // C éµï¼šåˆ‡æ›åº«å­˜/æ¨¡æ…‹è¦–çª—
                if (e.key.toLowerCase() === 'c') {
                    toggleInventory();
                }

                // æ•¸å­—éµï¼šåˆ‡æ›å¿«æ·æ¬„ (1 åˆ° 9)
                let keyIndex = parseInt(e.key) - 1;
                if (!isNaN(keyIndex) && keyIndex >= 0 && keyIndex <= 8) {
                    selectedHotbarIndex = keyIndex;
                    renderInventoryUI(); // æ›´æ–°é¸ä¸­ç‹€æ…‹
                    
                    const item = getSelectedItem();
                    const name = item.itemId ? itemDefinitions[item.itemId].name : 'ç©º';
                    showMessage(`å·²é¸æ“‡å¿«æ·æ¬„ ${keyIndex + 1}: ${name}`);
                }
            }
            
            /**
             * åˆ‡æ›åº«å­˜ä»‹é¢é¡¯ç¤ºç‹€æ…‹ã€‚
             */
            function toggleInventory() {
                isInventoryOpen = !isInventoryOpen;
                inventoryModal.style.display = isInventoryOpen ? 'flex' : 'none';
                
                if (isInventoryOpen) {
                    document.exitPointerLock();
                    renderInventoryUI(); // ç¢ºä¿åº«å­˜é–‹å•Ÿæ™‚ï¼ŒUI å¸¶æœ‰æ‹–æ›³åŠŸèƒ½
                    showMessage("åº«å­˜é–‹å•Ÿã€‚é»æ“Š C éµæˆ–ç•«é¢å¤–å€åŸŸé—œé–‰ã€‚");
                } else {
                    document.body.requestPointerLock().catch(() => {});
                    renderInventoryUI(); // ç¢ºä¿åº«å­˜é—œé–‰æ™‚ï¼ŒUI ç§»é™¤æ‹–æ›³åŠŸèƒ½
                }
            }


            function onMouseDown(event) {
                if (isGameOver || isInventoryOpen) return;
                
                if (document.pointerLockElement === document.body) {
                    const selectedItem = getSelectedItem();
                    const selectedItemId = selectedItem.itemId;

                    const raycaster = new THREE.Raycaster();
                    const origin = new THREE.Vector3();
                    camera.getWorldPosition(origin);
                    const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    raycaster.set(origin, direction);

                    const maxInteractionDistance = 5; 
                    const intersects = raycaster.intersectObjects(scene.children, true).filter(i => i.distance < maxInteractionDistance);

                    if (intersects.length > 0) {
                        const firstIntersect = intersects[0];
                        const rootObject = getRootObject(firstIntersect.object);
                        
                        if (event.button === 0) { // å·¦éµæŒ–æ˜æˆ–æ”»æ“Š
                            
                            if (rootObject.userData.isBlock) {
                                // æŒ–æ˜æ–¹å¡Šé‚è¼¯
                                const blockType = rootObject.userData.type;
                                const isStone = blockType === 'stone';
                                const isPickaxe = selectedItemId === 9; // æœ¨é¬ ID
                                
                                // æª¢æŸ¥å·¥å…·è€ä¹…åº¦
                                if (isStone && isPickaxe && currentPickaxeDurability <= 0) {
                                     showMessage("ä½ çš„æœ¨é¬å·²æå£ï¼Œç„¡æ³•æŒ–æ˜çŸ³é ­ã€‚");
                                     return;
                                }

                                // é–‹å§‹æŒ–æ˜
                                removeDiggingEffect();
                                isDigging = true;
                                diggingStartTime = performance.now();
                                diggingBlockId = rootObject.userData.blockId;

                                diggingEffect = new THREE.BoxHelper(rootObject, 0x00ff00);
                                scene.add(diggingEffect);
                                
                            } else if (rootObject.userData.type === 'pig') {
                                // æ”»æ“Šè±¬éš»é‚è¼¯ (ä¿æŒä¸è®Š)
                                const pigIndex = pigMeshes.findIndex(mesh => mesh === rootObject);
                                if (pigIndex !== -1) {
                                    const pigBody = pigBodies[pigIndex];
                                    pigBody.userData.health -= playerDamage;
                                    showMessage(`ä½ æ”»æ“Šäº†ä¸€é ­è±¬ï¼ (å‰©é¤˜ç”Ÿå‘½å€¼: ${pigBody.userData.health})`);
                                    if (pigBody.userData.health <= 0) {
                                        removePig(pigIndex);
                                    }
                                }
                            }
                        } else if (event.button === 2) { // å³éµå»ºé€ æˆ–åƒæ±è¥¿
                            
                            if (!selectedItemId) {
                                showMessage("ä½ æ‰‹ä¸Šæ²’æœ‰æ±è¥¿ï¼");
                                return;
                            }

                            const selectedDef = itemDefinitions[selectedItemId];

                            // 1. åƒæ±è¥¿é‚è¼¯
                            if (selectedDef.edible) {
                                const healAmount = 20;

                                if (selectedItem.stack > 0) {
                                    if (playerHealth < maxHealth) {
                                        // æ¶ˆè€—ç‰©å“
                                        selectedItem.stack--;
                                        if (selectedItem.stack === 0) selectedItem.itemId = null;
                                        
                                        // æ¢å¾©ç”Ÿå‘½å€¼
                                        playerHealth = Math.min(maxHealth, playerHealth + healAmount);
                                        updateHealthUI();
                                        renderInventoryUI();
                                        showMessage(`ä½ åƒäº† ${selectedDef.name}ï¼Œæ¢å¾©äº† ${healAmount} é»ç”Ÿå‘½å€¼ï¼`);
                                    } else {
                                        // ç”Ÿå‘½å€¼å·²æ»¿
                                        showMessage("ä½ çš„ç”Ÿå‘½å€¼å·²æ»¿ (100/100)ï¼Œç„¡æ³•é£Ÿç”¨ã€‚");
                                    }
                                } else {
                                    showMessage("ä½ çš„åº«å­˜è£¡æ²’æœ‰é€™å€‹ç‰©å“äº†ï¼");
                                }
                                return; // é—œéµï¼šè™•ç†é£Ÿç‰©å¾Œè¿”å›ï¼Œé¿å…åŸ·è¡Œæ”¾ç½®æ–¹å¡Šé‚è¼¯
                            }

                            // 2. æ”¾ç½®æ–¹å¡Šé‚è¼¯
                            if (selectedDef.tool) { // æœ¨é¬ç„¡æ³•æ”¾ç½®
                                showMessage(`${selectedDef.name} ç„¡æ³•æ”¾ç½®ã€‚`);
                                return;
                            }
                            
                            const blockTypeToPlace = selectedDef.blockType;
                            
                            if (selectedItem.stack > 0) {
                                const newBlockPos = firstIntersect.point.clone().add(firstIntersect.face.normal.clone().multiplyScalar(BLOCK_DIMENSIONS / 2));
                                
                                const placeX = Math.round(newBlockPos.x);
                                const placeY = Math.round(newBlockPos.y);
                                const placeZ = Math.round(newBlockPos.z);
                                
                                // ç°¡æ˜“æª¢æŸ¥æ”¾ç½®ä½ç½®æ˜¯å¦èˆ‡ç©å®¶é‡ç–Š
                                if (
                                    placeX === Math.round(player.position.x) && 
                                    placeZ === Math.round(player.position.z) && 
                                    (placeY === Math.round(player.position.y) || placeY === Math.round(player.position.y + 1)) 
                                ) {
                                    showMessage("ä½ ä¸èƒ½å°‡æ–¹å¡Šæ”¾ç½®åœ¨ä½ çš„èº«é«”è£¡ï¼");
                                    return;
                                }

                                addBlock(placeX, placeY, placeZ, blockTypeToPlace);
                                selectedItem.stack--;
                                if (selectedItem.stack === 0) selectedItem.itemId = null;
                                
                                renderInventoryUI();
                                showMessage(`ä½ æ”¾ç½®äº†ä¸€å€‹${selectedDef.name}ï¼`);
                            } else {
                                showMessage("ä½ çš„åº«å­˜è£¡æ²’æœ‰é€™å€‹æ–¹å¡Šäº†ï¼");
                            }
                        }
                    }
                } else {
                    // å¦‚æœæ»‘é¼ æ²’æœ‰é–å®š (å³åº«å­˜å·²é—œé–‰)ï¼Œé»æ“Šæ™‚å˜—è©¦é–å®š
                    if (!isInventoryOpen) {
                         document.body.requestPointerLock().catch(() => {});
                    }
                }
            }

            function onMouseUp(event) {
                // å¦‚æœæ”¾é–‹æ»‘é¼ å·¦éµï¼Œåœæ­¢æŒ–æ˜ä¸¦ç§»é™¤æ•ˆæœ
                if (event.button === 0 && !isInventoryOpen) {
                    isDigging = false;
                    diggingBlockId = null;
                    removeDiggingEffect();
                    showMessage('');
                }
            }
            
            function onMouseMove(event) {
                 // åªæœ‰åœ¨åº«å­˜é—œé–‰æ™‚æ‰å…è¨±è¦–è§’ç§»å‹•
                if (document.pointerLockElement === document.body && !isInventoryOpen) {
                    const movementX = event.movementX || event.mozMovementX || 0;
                    const movementY = event.movementY || event.mozMovementY || 0;

                    const euler = new THREE.Euler(0, 0, 0, 'YXZ');
                    euler.setFromQuaternion(camera.quaternion);

                    euler.y -= movementX * 0.002;
                    euler.x -= movementY * 0.002;

                    euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));

                    camera.quaternion.setFromEuler(euler);
                }
            }
            
            function updatePlayerMovement() {
                const speed = 5;
                const velocity = new CANNON.Vec3(0, playerBody.velocity.y, 0); 
                
                // åªæœ‰åœ¨åº«å­˜é—œé–‰æ™‚æ‰å…è¨±ç§»å‹•
                if (isInventoryOpen) {
                    playerBody.velocity.x = 0;
                    playerBody.velocity.z = 0;
                    return;
                }

                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);

                let moveX = 0;
                let moveZ = 0;

                if (keyboard['w']) { moveX += forward.x; moveZ += forward.z; }
                if (keyboard['s']) { moveX -= forward.x; moveZ -= forward.z; }
                if (keyboard['a']) { moveX -= right.x; moveZ -= right.z; }
                if (keyboard['d']) { moveX += right.x; moveZ += right.z; }

                const magnitude = Math.sqrt(moveX * moveX + moveZ * moveZ);
                if (magnitude > 0) {
                    moveX /= magnitude;
                    moveZ /= magnitude;
                }

                playerBody.velocity.x = moveX * speed;
                playerBody.velocity.z = moveZ * speed;

                if (keyboard[' '] && canJump) {
                    const jumpVelocity = 6;
                    playerBody.velocity.y = jumpVelocity;
                    canJump = false; 
                }
            }


            function animate(time) {
                if (isGameOver) return;

                requestAnimationFrame(animate);
                
                let dt = (time - (lastTime || time)) / 1000;
                const maxDt = 1 / 10; 
                const safeDt = Math.min(dt, maxDt);
                lastTime = time; 
                
                // --- éŠæˆ²é‚è¼¯æ›´æ–° ---
                if (!isInventoryOpen) {
                    world.step(1/60, safeDt, 3);
                    
                    // æ ¹æ“šæ–°çš„æ™‚é–“åŠ é€Ÿä¿‚æ•¸æ›´æ–°éŠæˆ²æ™‚é–“: 1 ç§’ (safeDt) = 1/60 éŠæˆ²å°æ™‚
                    gameTime = (gameTime + safeDt * REAL_SECOND_TO_GAME_HOUR_FACTOR) % 24; 
                    updateTimeAndLighting(gameTime);

                    updatePlayerMovement();
                    updatePigs(time);
                    
                    player.position.copy(playerBody.position);

                    // æª¢æŸ¥æŒ–æ˜é€²åº¦ (åªæœ‰åœ¨éåº«å­˜ç‹€æ…‹ä¸‹æ‰æ›´æ–°)
                    checkDiggingProgress(time);
                    checkSaplingGrowth(time);
                    checkFallDamage();
                    
                    if (time - lastCullTime > 5000) {
                        cullDistantObjects();
                        lastCullTime = time;
                    }
                } else {
                    // åº«å­˜é–‹å•Ÿæ™‚ï¼Œä»é ˆæª¢æŸ¥è€ä¹…åº¦ï¼Œä½†éŠæˆ²ä¸å‹•
                    updateDurabilityUI();
                }
                
                renderer.render(scene, camera);
            }
            
            // --- æŒ–æ˜é‚è¼¯ ---
            function checkDiggingProgress(time) {
                if (isDigging && diggingBlockId) {
                    const selectedItem = getSelectedItem();
                    const selectedItemId = selectedItem.itemId;
                    
                    // æª¢æŸ¥ç›®æ¨™æ–¹å¡Šæ˜¯å¦é‚„å­˜åœ¨ (é˜²æ­¢æŒ–æ˜ç›®æ¨™æ¶ˆå¤±å¾Œé€²åº¦æ¢ä¸æ¶ˆå¤±)
                    const blockMesh = blockMeshes.get(diggingBlockId);
                    if (!blockMesh) {
                         isDigging = false;
                         diggingBlockId = null;
                         removeDiggingEffect();
                         showMessage('æŒ–æ˜å·²ä¸­æ–·ã€‚');
                         return;
                    }
                    
                    const blockType = blockMesh.userData.type;
                    let duration = blockDurations[blockType] || 2000;

                    // åŠ é€ŸæŒ–æ˜ï¼šæœ¨é¬(9)æŒ–çŸ³é ­(3)
                    const isPickaxe = selectedItemId === 9; 
                    const isStone = blockType === 'stone';
                    
                    if (isPickaxe && isStone) {
                        duration /= 1.5;
                    }

                    const elapsedTime = time - diggingStartTime;
                    const progress = Math.min(1, elapsedTime / duration);
                    const progressPercentage = Math.round(progress * 100);

                    // æ›´æ–°æŒ–æ˜æ•ˆæœ
                    const color = new THREE.Color(0x00ff00).lerp(new THREE.Color(0xff0000), progress);
                    if (!diggingEffect) {
                        diggingEffect = new THREE.BoxHelper(blockMesh, 0x00ff00);
                        scene.add(diggingEffect);
                    }
                    diggingEffect.material.color.copy(color);

                    showMessage(`æ­£åœ¨æŒ–æ˜ ${blockType} æ–¹å¡Š... (${progressPercentage}%)`);

                    if (elapsedTime >= duration) {
                        // æŒ–æ˜å®Œæˆ
                        const minedItemId = getItemIdByBlockType(blockType);

                        // --- è€ä¹…åº¦æ‰£é™¤é‚è¼¯ ---
                        if (isPickaxe && isStone && selectedItem.stack > 0) {
                            currentPickaxeDurability--;
                            
                            if (currentPickaxeDurability <= 0) {
                                selectedItem.stack--; // æ¶ˆè€—ä¸€å€‹å·¥å…·
                                
                                if (selectedItem.stack > 0) {
                                    currentPickaxeDurability = WOODEN_PICKAXE_MAX_DURABILITY;
                                    showMessage("ä½ çš„æœ¨é¬å£äº†ï¼å¹¸å¥½ä½ é‚„æœ‰å‚™ç”¨çš„ã€‚");
                                } else {
                                    selectedItem.itemId = null; // è©²æ§½ä½æ¸…ç©º
                                    currentPickaxeDurability = 0;
                                    showMessage("ä½ çš„æœ¨é¬å¾¹åº•å£äº†ï¼Œå¿…é ˆå†åˆæˆä¸€å€‹ï¼");
                                }
                            }
                        }
                        
                        // è™•ç†æ¨¹è‘‰æ‰è½æ¨¹è‹—
                        let dropCount = 1;
                        if (blockType === 'leaves' && Math.random() < 0.3) {
                            addItemToInventory(10, 1); // æ‰è½æ¨¹è‹— ID 10
                            dropCount = 0; // ä¸å†æ‰è½æ¨¹è‘‰æ–¹å¡Šæœ¬èº«
                        }
                        
                        // å¢åŠ ç‰©å“åˆ°åº«å­˜
                        if (minedItemId && dropCount > 0) {
                             addItemToInventory(minedItemId, dropCount);
                             showMessage(`ä½ æŒ–æ˜äº†ä¸€å€‹${itemDefinitions[minedItemId].name}ï¼`);
                        }
                        
                        removeBlock(diggingBlockId);
                        removeDiggingEffect(); 
                        isDigging = false;
                        diggingBlockId = null;
                        renderInventoryUI(); // æ›´æ–°è€ä¹…åº¦
                    }
                }
            }
            
            function checkFallDamage() {
                // æ²¿ç”¨èˆŠçš„å¢œè½å‚·å®³æª¢æŸ¥é‚è¼¯
                const currentY = playerBody.position.y;
                const velocityY = playerBody.velocity.y;
                const tolerance = 0.1; 

                if (velocityY < -tolerance && !isFalling) {
                    isFalling = true;
                    fallStartY = currentY;
                } 
                
                // åœ°é¢æª¢æŸ¥ (Raycasting)
                const rayStart = playerBody.position;
                const rayEnd = new CANNON.Vec3(rayStart.x, rayStart.y - 1.0, rayStart.z); 
                const result = new CANNON.RaycastResult();
                world.raycastClosest(rayStart, rayEnd, { skip: [playerBody] }, result);
                canJump = result.hasHit;
                
                if (isFalling && canJump) {
                    const fallDistance = fallStartY - currentY;
                    
                    if (fallDistance >= minFallHeight) {
                        const damage = Math.round((fallDistance - minFallHeight) * fallDamageFactor);

                        if (damage > 0) {
                            takeDamage(damage);
                            showMessage(`ä½ å¾ ${fallDistance.toFixed(1)} æ ¼é«˜è™•æ‘”è½ï¼Œå—åˆ°äº† ${damage} é»å‚·å®³ï¼`);
                            if (playerHealth <= 0) {
                                gameOver();
                            }
                        }
                    } 
                    
                    isFalling = false;
                    fallStartY = null;
                }
            }
            
            // --- é›œé … UI/éŠæˆ²è¼”åŠ©å‡½æ•¸ (æ›´æ–° updateHealthUI) ---

            /**
             * è®“ç©å®¶å—åˆ°å‚·å®³ã€‚
             * @param {number} damageAmount - å‚·å®³é‡ã€‚
             */
            function takeDamage(damageAmount) {
                playerHealth = Math.max(0, playerHealth - damageAmount);
                updateHealthUI();
                if (playerHealth === 0) {
                    gameOver();
                }
            }

            function updateDurabilityUI() {
                const selectedItem = getSelectedItem();
                const isPickaxeSelected = selectedItem.itemId === 9; // æœ¨é¬ ID

                if (isPickaxeSelected && selectedItem.stack > 0) {
                    durabilityDisplay.style.display = 'block';
                    durabilityDisplay.textContent = `æœ¨é¬è€ä¹…åº¦: ${currentPickaxeDurability} / ${WOODEN_PICKAXE_MAX_DURABILITY}`;
                    
                    if (currentPickaxeDurability < 10) {
                        durabilityDisplay.style.backgroundColor = 'rgba(231, 76, 60, 0.8)';
                    } else if (currentPickaxeDurability < 30) {
                        durabilityDisplay.style.backgroundColor = 'rgba(241, 196, 15, 0.8)';
                    } else {
                        durabilityDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
                    }
                } else {
                    durabilityDisplay.style.display = 'none';
                }
            }

            function updateTimeAndLighting(time) {
                 const dayColor = new THREE.Color(0x70a1d6);
                 const nightColor = new THREE.Color(0x1a1a33);
                 
                 let skyColor;
                 if (time >= 6 && time < 18) { skyColor = dayColor; } 
                 else if (time >= 18 && time < 19) { const factor = time - 18; skyColor = dayColor.clone().lerp(nightColor, factor); } 
                 else if (time >= 5 && time < 6) { const factor = 6 - time; skyColor = nightColor.clone().lerp(dayColor, 1 - factor); } 
                 else { skyColor = nightColor; }

                 scene.background = skyColor;

                 let ambientIntensity;
                 if (time >= 6 && time < 18) { ambientIntensity = 0.8; } 
                 else if (time >= 18 && time < 19) { ambientIntensity = THREE.MathUtils.lerp(0.8, 0.2, time - 18); } 
                 else if (time >= 5 && time < 6) { ambientIntensity = THREE.MathUtils.lerp(0.2, 0.8, time - 5); } 
                 else { ambientIntensity = 0.2; }
                 ambientLight.intensity = ambientIntensity;

                 let sunMoonIntensity = ambientIntensity * 1.2; 
                 if (time > 18 || time < 6) { sunMoonIntensity *= 0.5; }
                 directionalLight.intensity = sunMoonIntensity;
                 
                 const angle = (time / 24) * Math.PI * 2; 
                 const sunX = Math.sin(angle) * 20;
                 const sunY = Math.cos(angle) * 20;
                 directionalLight.position.set(sunX, sunY, 0);
                 directionalLight.lookAt(0, 0, 0);
                 
                 const hours = Math.floor(time) % 24;
                 const minutes = Math.floor((time - hours) * 60);
                 const displayHours = isNaN(hours) ? '06' : String(hours).padStart(2, '0');
                 const displayMinutes = isNaN(minutes) ? '00' : String(minutes).padStart(2, '0');

                 timeDisplay.textContent = `æ™‚é–“: ${displayHours}:${displayMinutes}`;
            }

            function updateHealthUI() {
                playerHealth = Math.max(0, Math.min(maxHealth, playerHealth));
                healthBar.style.width = `${(playerHealth / maxHealth) * 100}%`;
                healthText.textContent = `${playerHealth} / ${maxHealth}`;
            }

            function showMessage(text) {
                messageBox.textContent = text;
            }
            
            // ... (å…¶ä»–æœªè®Šå‹•çš„éŠæˆ²é‚è¼¯å‡½æ•¸)
            
            function generateWorld() {
                const groundMaterial = new CANNON.Material();
                const groundBody = new CANNON.Body({
                    mass: 0,
                    shape: new CANNON.Plane(),
                    material: groundMaterial
                });
                groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                world.addBody(groundBody);

                for (let x = -15; x <= 15; x++) {
                    for (let z = -15; z <= 15; z++) {
                        const y = Math.floor(Math.random() * 2) - 1;
                        addBlock(x, y, z, 'grass');
                        addBlock(x, y - 1, z, 'dirt');
                        addBlock(x, y - 2, z, 'stone');
                    }
                }
                
                const numTrees = 5;
                for (let i = 0; i < numTrees; i++) {
                    const x = (Math.random() - 0.5) * 20;
                    const z = (Math.random() - 0.5) * 20;
                    createTree(Math.round(x), 0, Math.round(z));
                }
            }

            function createTree(x, y, z) {
                const trunkHeight = 3 + Math.floor(Math.random() * 2);
                for (let i = 0; i < trunkHeight; i++) {
                    addBlock(x, y + i, z, 'wood');
                }

                const leavesHeight = trunkHeight + 1;
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        for (let k = -1; k <= 1; k++) {
                            if (!(i === 0 && j === 0 && k === 0) || Math.abs(i) + Math.abs(j) + Math.abs(k) === 1) {
                                addBlock(x + i, leavesHeight + j, z + k, 'leaves');
                            }
                        }
                    }
                }
            }

            function createPigs() {
                const numPigs = 5;
                for (let i = 0; i < numPigs; i++) {
                    const x = (Math.random() - 0.5) * 20;
                    const z = (Math.random() - 0.5) * 20;
                    createPig(x, 1, z);
                }
            }

            function createPig(x, y, z) {
                const pigGroup = new THREE.Group();
                const pigColor = blockColors['pig'];

                const bodyGeometry = new THREE.BoxGeometry(1.2, 0.8, 2);
                const bodyMaterial = new THREE.MeshPhongMaterial({ color: pigColor });
                const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
                pigGroup.add(bodyMesh);

                const headGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const headMaterial = new THREE.MeshPhongMaterial({ color: pigColor });
                const headMesh = new THREE.Mesh(headGeometry, headMaterial);
                headMesh.position.z = 1.4;
                pigGroup.add(headMesh);
                
                pigGroup.position.set(x, y, z);
                scene.add(pigGroup);
                
                pigGroup.userData = { type: 'pig' };

                const pigShape = new CANNON.Box(new CANNON.Vec3(0.6, 0.4, 1));
                const pigBody = new CANNON.Body({ mass: 1, position: new CANNON.Vec3(x, y, z), shape: pigShape });
                pigBody.userData = { type: 'pig', health: 20, lastWanderTime: 0 };
                pigBody.linearDamping = 0.9;
                world.addBody(pigBody);

                pigMeshes.push(pigGroup);
                pigBodies.push(pigBody);
            }

            function createPlayer() {
                player = new THREE.Object3D();
                scene.add(player);
                player.position.set(0, 5, 0);

                const playerShape = new CANNON.Cylinder(0.5, 0.5, 1.8, 16); 
                playerBody = new CANNON.Body({ mass: 1, position: new CANNON.Vec3(0, 5, 0), shape: playerShape });
                playerBody.fixedRotation = true;
                playerBody.linearDamping = 0.95; 
                world.addBody(playerBody);

                player.add(camera);
                camera.position.set(0, 0.9, 0); 
            }

            function addBlock(x, y, z, type) {
                const blockGeometry = new THREE.BoxGeometry(BLOCK_DIMENSIONS, BLOCK_DIMENSIONS, BLOCK_DIMENSIONS);
                const blockMaterial = new THREE.MeshPhongMaterial({ color: blockColors[type] });
                const mesh = new THREE.Mesh(blockGeometry, blockMaterial);
                scene.add(mesh);
                mesh.position.set(x, y, z);
                
                const blockId = `${x}-${y}-${z}`;
                mesh.userData = { type: type, blockId: blockId, isBlock: true };

                const blockShape = new CANNON.Box(new CANNON.Vec3(BLOCK_DIMENSIONS/2, BLOCK_DIMENSIONS/2, BLOCK_DIMENSIONS/2));
                const blockBody = new CANNON.Body({ mass: 0, position: new CANNON.Vec3(x, y, z), shape: blockShape });
                blockBody.userData = { blockId: blockId, isBlock: true };
                world.addBody(blockBody);
                
                blockMeshes.set(blockId, mesh);
                blockBodies.set(blockId, blockBody);

                if (type === 'sapling') {
                    saplingGrowthTracker.set(blockId, performance.now());
                }
            }

            function removeBlock(blockId) {
                const blockMesh = blockMeshes.get(blockId);
                const blockBody = blockBodies.get(blockId);

                if (blockMesh) {
                    scene.remove(blockMesh);
                    blockMeshes.delete(blockId);
                }

                if (blockBody) {
                    world.removeBody(blockBody);
                    blockBodies.delete(blockId);
                }

                if (saplingGrowthTracker.has(blockId)) {
                    saplingGrowthTracker.delete(blockId);
                }
            }

            function removeDiggingEffect() {
                if (diggingEffect) {
                    scene.remove(diggingEffect);
                    diggingEffect = null;
                }
            }

            function removePig(pigIndex) {
                if (pigIndex < 0 || pigIndex >= pigMeshes.length) return;
                
                // æ‰è½è±¬è‚‰ (ID 11)
                addItemToInventory(11, 1);

                scene.remove(pigMeshes[pigIndex]);
                world.removeBody(pigBodies[pigIndex]);
                pigMeshes.splice(pigIndex, 1);
                pigBodies.splice(pigIndex, 1);
                
                showMessage("ä½ æ“Šæ•—äº†ä¸€é ­è±¬ï¼Œç²å¾—äº†ä¸€å¡Šè±¬è‚‰ï¼");
            }

            function getRootObject(object) {
                return object.parent && object.parent.isGroup ? object.parent : object;
            }

            window.onload = function() {
                init();
            };

            document.addEventListener('contextmenu', (e) => e.preventDefault());

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            function pointerLockChange() {
                if (document.pointerLockElement === document.body) {
                    if (!isInventoryOpen) {
                         showMessage("é»æ“Šæ»‘é¼ å·¦éµæŒ–æ˜/æ”»æ“Šï¼Œå³éµå»ºé€ /é€²é£Ÿã€‚æŒ‰ç©ºç™½éµè·³èºã€‚");
                    }
                } else {
                    if (!isInventoryOpen) {
                        showMessage("é»æ“Šç•«é¢ä»¥æ§åˆ¶äººç‰©ã€‚æŒ‰ C éµæ‰“é–‹èƒŒåŒ…ã€‚éŠæˆ²æ™‚é–“ç‚º 1:60 åŠ é€Ÿã€‚");
                    }
                }
            }
            
            function gameOver() {
                isGameOver = true;
                document.exitPointerLock();
                
                showMessage("éŠæˆ²çµæŸï¼ä½ çš„ç”Ÿå‘½å€¼ç‚ºé›¶ã€‚è«‹é‡æ–°æ•´ç†é é¢ä»¥é‡æ–°é–‹å§‹ã€‚");
            }

            function checkSaplingGrowth(currentTime) {
                const saplingsToGrow = [];
                const growthDuration = 30000; 

                for (const [blockId, placementTime] of saplingGrowthTracker.entries()) {
                    if (currentTime - placementTime >= growthDuration) {
                        saplingsToGrow.push(blockId);
                    }
                }

                for (const blockId of saplingsToGrow) {
                    const mesh = blockMeshes.get(blockId);
                    if (mesh) {
                        const { x, y, z } = mesh.position;
                        removeBlock(blockId); 
                        createTree(Math.round(x), Math.round(y), Math.round(z)); 
                        showMessage(`ä¸€é¡†æ¨¹è‹—åœ¨ (${Math.round(x)}, ${Math.round(y)}, ${Math.round(z)}) è™•é•·æˆäº†ä¸€æ£µæ¨¹!`);
                    }
                    saplingGrowthTracker.delete(blockId);
                }
            }
            
            function updatePigs(time) {
                for (let i = 0; i < pigMeshes.length; i++) {
                    const pigBody = pigBodies[i];
                    const pigPosition = pigBody.position;
                    
                    pigMeshes[i].position.copy(pigPosition);
                    pigMeshes[i].quaternion.copy(pigBody.quaternion);

                    if (time - pigBody.userData.lastWanderTime > 5000) {
                        const randomDirection = new CANNON.Vec3((Math.random() - 0.5) * 5, 0, (Math.random() - 0.5) * 5);
                        randomDirection.normalize();
                        randomDirection.scale(1, randomDirection);
                        pigBody.velocity.set(randomDirection.x, pigBody.velocity.y, randomDirection.z);
                        pigBody.userData.lastWanderTime = time;
                    }
                }
            }
            
            function cullDistantObjects() {
                const playerPosition = player.position;
                
                const blockKeys = Array.from(blockMeshes.keys());
                for (const blockId of blockKeys) {
                    const mesh = blockMeshes.get(blockId);
                    if (mesh && playerPosition.distanceTo(mesh.position) > cullingDistance) {
                        removeBlock(blockId);
                    }
                }

                for (let i = pigMeshes.length - 1; i >= 0; i--) {
                    const pigMesh = pigMeshes[i];
                    if (playerPosition.distanceTo(pigMesh.position) > cullingDistance) {
                        removePig(i);
                    }
                }
            }
            
        })();
    </script>
</body>
</html>
